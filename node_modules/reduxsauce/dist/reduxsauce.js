'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var isNil = require('ramda/src/isNil');
var is = require('ramda/src/is');
var has = require('ramda/src/has');
var any = require('ramda/src/any');
var equals = require('ramda/src/equals');
var keys = require('ramda/src/keys');
var pipe = require('ramda/src/pipe');
var trim = require('ramda/src/trim');
var merge = require('ramda/src/merge');
var split = require('ramda/src/split');
var reject = require('ramda/src/reject');
var map = require('ramda/src/map');
var fromPairs = require('ramda/src/fromPairs');
var anyPass = require('ramda/src/anyPass');
var isEmpty = require('ramda/src/isEmpty');
var join = require('ramda/src/join');
var mapObjIndexed = require('ramda/src/mapObjIndexed');
var pick = require('ramda/src/pick');
var replace = require('ramda/src/replace');
var toUpper = require('ramda/src/toUpper');
var zipObj = require('ramda/src/zipObj');
var curry = require('ramda/src/curry');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var isNil__default = /*#__PURE__*/_interopDefaultLegacy(isNil);
var is__default = /*#__PURE__*/_interopDefaultLegacy(is);
var has__default = /*#__PURE__*/_interopDefaultLegacy(has);
var any__default = /*#__PURE__*/_interopDefaultLegacy(any);
var equals__default = /*#__PURE__*/_interopDefaultLegacy(equals);
var keys__default = /*#__PURE__*/_interopDefaultLegacy(keys);
var pipe__default = /*#__PURE__*/_interopDefaultLegacy(pipe);
var trim__default = /*#__PURE__*/_interopDefaultLegacy(trim);
var merge__default = /*#__PURE__*/_interopDefaultLegacy(merge);
var split__default = /*#__PURE__*/_interopDefaultLegacy(split);
var reject__default = /*#__PURE__*/_interopDefaultLegacy(reject);
var map__default = /*#__PURE__*/_interopDefaultLegacy(map);
var fromPairs__default = /*#__PURE__*/_interopDefaultLegacy(fromPairs);
var anyPass__default = /*#__PURE__*/_interopDefaultLegacy(anyPass);
var isEmpty__default = /*#__PURE__*/_interopDefaultLegacy(isEmpty);
var join__default = /*#__PURE__*/_interopDefaultLegacy(join);
var mapObjIndexed__default = /*#__PURE__*/_interopDefaultLegacy(mapObjIndexed);
var pick__default = /*#__PURE__*/_interopDefaultLegacy(pick);
var replace__default = /*#__PURE__*/_interopDefaultLegacy(replace);
var toUpper__default = /*#__PURE__*/_interopDefaultLegacy(toUpper);
var zipObj__default = /*#__PURE__*/_interopDefaultLegacy(zipObj);
var curry__default = /*#__PURE__*/_interopDefaultLegacy(curry);

var DEFAULT = 'REDUXSAUCE.DEFAULT';

var Types = /*#__PURE__*/Object.freeze({
  __proto__: null,
  DEFAULT: DEFAULT
});

/**
  Creates a reducer.
  @param {string} initialState - The initial state for this reducer.
  @param {object} handlers - Keys are action types (strings), values are reducers (functions).
  @return {object} A reducer object.
 */

var cr = (function (initialState, handlers) {
  // initial state is required
  if (initialState === undefined) {
    throw new Error('initial state is required');
  } // handlers must be an object


  if (isNil__default['default'](handlers) || !is__default['default'](Object, handlers)) {
    throw new Error('handlers must be an object');
  } // handlers cannot have an undefined key


  if (any__default['default'](equals__default['default']('undefined'))(keys__default['default'](handlers))) {
    throw new Error('handlers cannot have an undefined key');
  } // create the reducer function


  return function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
    var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    // wrong actions, just return state
    if (isNil__default['default'](action)) return state;
    if (!has__default['default']('type', action)) return state; // look for the handler

    var handler = handlers[action.type] || handlers[DEFAULT]; // no handler no cry

    if (isNil__default['default'](handler)) return state; // execute the handler

    return handler(state, action);
  };
});

var isNilOrEmpty = anyPass__default['default']([isNil__default['default'], isEmpty__default['default']]);
var defaultOptions$1 = {
  prefix: ''
};
var ct = (function (types) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (isNilOrEmpty(types)) throw new Error('valid types are required');

  var _merge = merge__default['default'](defaultOptions$1, options),
      prefix = _merge.prefix;

  return pipe__default['default'](trim__default['default'], split__default['default'](/\s/), map__default['default'](trim__default['default']), reject__default['default'](isNilOrEmpty), map__default['default'](function (x) {
    return [x, prefix + x];
  }), fromPairs__default['default'])(types);
});

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defaultOptions = {
  prefix: ''
}; // matches each word in a camelCaseString (except the first)
// consecutive capitals are treated as one word

var RX_CAPS = /(?!^)([A-Z][a-z0-9]+|[A-Z][A-Z0-9]*(?=[A-Z]|\b))/g; // converts a camelCaseWord into a SCREAMING_SNAKE_CASE word

var camelToScreamingSnake = pipe__default['default'](replace__default['default'](RX_CAPS, '_$1'), toUpper__default['default']); // build Action Types out of an object

var convertToTypes = function convertToTypes(config, options) {
  var opts = merge__default['default'](defaultOptions, options);
  return pipe__default['default'](keys__default['default'], // just the keys
  map__default['default'](camelToScreamingSnake), // CONVERT_THEM
  join__default['default'](' '), // space separated
  function (types) {
    return ct(types, opts);
  } // make them into Redux Types
  )(config);
}; // an action creator with additional properties


var createActionCreator = function createActionCreator(name, extraPropNames, options) {
  var _merge = merge__default['default'](defaultOptions, options),
      prefix = _merge.prefix; // types are upcase and snakey


  var type = "".concat(prefix).concat(camelToScreamingSnake(name)); // do we need extra props for this?

  var noKeys = isNil__default['default'](extraPropNames) || isEmpty__default['default'](extraPropNames); // a type-only action creator

  if (noKeys) return function () {
    return {
      type: type
    };
  }; // an action creator with type + properties
  // "properties" is defined as an array of prop names

  if (is__default['default'](Array, extraPropNames)) {
    return function () {
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }

      var extraProps = zipObj__default['default'](extraPropNames, values);
      return _objectSpread2({
        type: type
      }, extraProps);
    };
  } // an action creator with type + properties
  // "properties" is defined as an object of {prop name: default value}


  if (is__default['default'](Object, extraPropNames)) {
    var defaultProps = extraPropNames;
    return function () {
      var valueObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var providedProps = pick__default['default'](Object.keys(defaultProps), valueObject);
      return _objectSpread2(_objectSpread2({
        type: type
      }, defaultProps), providedProps);
    };
  }

  throw new Error('action props must be a null/array/object/function');
}; // build Action Creators out of an object


var convertToCreators = function convertToCreators(config, options) {
  return mapObjIndexed__default['default'](function (num, key, value) {
    if (typeof value[key] === 'function') {
      // the user brought their own action creator
      return value[key];
    } else {
      // lets make an action creator for them!
      return createActionCreator(key, value[key], options);
    }
  })(config);
};

var ca = (function (config, options) {
  if (isNil__default['default'](config)) {
    throw new Error('an object is required to setup types and creators');
  }

  if (isEmpty__default['default'](config)) {
    throw new Error('empty objects are not supported');
  }

  return {
    Types: convertToTypes(config, options),
    Creators: convertToCreators(config, options)
  };
});

/**
 * Allows your reducers to be reset.
 *
 * @param {string} typeToReset - The action type to listen for.
 * @param {function} originalReducer - The reducer to wrap.
 */

function resettableReducer$1(typeToReset, originalReducer) {
  // a valid type is required
  if (!is__default['default'](String, typeToReset) || typeToReset === '') {
    throw new Error('A valid reset type is required.');
  } // an original reducer is required


  if (typeof originalReducer !== 'function') {
    throw new Error('A reducer is required.');
  } // run it through first to get what the default state should be


  var resetState = originalReducer(undefined, {}); // create our own reducer that wraps the original one and hijacks the reset

  function reducer() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resetState;
    var action = arguments.length > 1 ? arguments[1] : undefined;

    if (action && action.type === typeToReset) {
      return resetState;
    } else {
      return originalReducer(state, action);
    }
  }

  return reducer;
}

var rr = curry__default['default'](resettableReducer$1);

var createReducer = cr;
var createTypes = ct;
var createActions = ca;
var resettableReducer = rr;

exports.Types = Types;
exports.createActions = createActions;
exports.createReducer = createReducer;
exports.createTypes = createTypes;
exports.resettableReducer = resettableReducer;
